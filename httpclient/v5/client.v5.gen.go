// Package v5 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package v5

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
)

const (
	BearerScopes = "bearer.Scopes"
)

// Defines values for ConnectionCompetitiveEntryType.
const (
	Competitive ConnectionCompetitiveEntryType = "competitive"
)

// Defines values for ConnectionLabEntryType.
const (
	Fortresses    ConnectionLabEntryType = "fortresses"
	Labs          ConnectionLabEntryType = "labs"
	StartingPoint ConnectionLabEntryType = "starting_point"
)

// Defines values for ConnectionProLabEntryType.
const (
	ConnectionProLabEntryTypeProlab ConnectionProLabEntryType = "prolab"
)

// Defines values for MachineOwnResponseOwnType.
const (
	MachineOwnResponseOwnTypeRoot MachineOwnResponseOwnType = "Root"
	MachineOwnResponseOwnTypeUser MachineOwnResponseOwnType = "User"
)

// Defines values for UserProfileActivityChallengeType.
const (
	UserProfileActivityChallengeTypeChallenge UserProfileActivityChallengeType = "challenge"
)

// Defines values for UserProfileActivityFortressType.
const (
	Fortress UserProfileActivityFortressType = "fortress"
)

// Defines values for UserProfileActivityMachineOwnType.
const (
	UserProfileActivityMachineOwnTypeRoot UserProfileActivityMachineOwnType = "root"
	UserProfileActivityMachineOwnTypeUser UserProfileActivityMachineOwnType = "user"
)

// Defines values for UserProfileActivityProlabType.
const (
	UserProfileActivityProlabTypeProlab UserProfileActivityProlabType = "prolab"
)

// Defines values for UserProfileActivitySherlockType.
const (
	UserProfileActivitySherlockTypeSherlock UserProfileActivitySherlockType = "sherlock"
)

// Defines values for Free.
const (
	FreeN0 Free = 0
	FreeN1 Free = 1
)

// Defines values for ShowCompleted.
const (
	ShowCompletedComplete   ShowCompleted = "complete"
	ShowCompletedIncomplete ShowCompleted = "incomplete"
)

// Defines values for SortBy.
const (
	SortByName           SortBy = "name"
	SortByRating         SortBy = "rating"
	SortByReleaseDate    SortBy = "release_date"
	SortBySystemOwns     SortBy = "system_owns"
	SortByUserDifficulty SortBy = "user_difficulty"
	SortByUserOwns       SortBy = "user_owns"
)

// Defines values for SortType.
const (
	SortTypeAsc  SortType = "asc"
	SortTypeDesc SortType = "desc"
)

// Defines values for Todo.
const (
	TodoN1 Todo = 1
)

// Defines values for UserProfileContentType.
const (
	UserProfileContentTypeChallenge UserProfileContentType = "challenge"
	UserProfileContentTypeMachine   UserProfileContentType = "machine"
	UserProfileContentTypeSherlock  UserProfileContentType = "sherlock"
)

// Defines values for GetMachinesParamsState.
const (
	Active     GetMachinesParamsState = "active"
	Retired    GetMachinesParamsState = "retired"
	Unreleased GetMachinesParamsState = "unreleased"
)

// Defines values for GetMachinesParamsDifficulty.
const (
	Easy   GetMachinesParamsDifficulty = "easy"
	Hard   GetMachinesParamsDifficulty = "hard"
	Insane GetMachinesParamsDifficulty = "insane"
	Medium GetMachinesParamsDifficulty = "medium"
)

// Defines values for GetMachinesParamsOs.
const (
	Freebsd GetMachinesParamsOs = "freebsd"
	Linux   GetMachinesParamsOs = "linux"
	Openbsd GetMachinesParamsOs = "openbsd"
	Other   GetMachinesParamsOs = "other"
	Windows GetMachinesParamsOs = "windows"
)

// Defines values for GetMachinesParamsShowCompleted.
const (
	GetMachinesParamsShowCompletedComplete   GetMachinesParamsShowCompleted = "complete"
	GetMachinesParamsShowCompletedIncomplete GetMachinesParamsShowCompleted = "incomplete"
)

// Defines values for GetMachinesParamsSortBy.
const (
	GetMachinesParamsSortByName           GetMachinesParamsSortBy = "name"
	GetMachinesParamsSortByRating         GetMachinesParamsSortBy = "rating"
	GetMachinesParamsSortByReleaseDate    GetMachinesParamsSortBy = "release_date"
	GetMachinesParamsSortBySystemOwns     GetMachinesParamsSortBy = "system_owns"
	GetMachinesParamsSortByUserDifficulty GetMachinesParamsSortBy = "user_difficulty"
	GetMachinesParamsSortByUserOwns       GetMachinesParamsSortBy = "user_owns"
)

// Defines values for GetMachinesParamsSortType.
const (
	GetMachinesParamsSortTypeAsc  GetMachinesParamsSortType = "asc"
	GetMachinesParamsSortTypeDesc GetMachinesParamsSortType = "desc"
)

// Defines values for GetMachinesParamsFree.
const (
	GetMachinesParamsFreeN0 GetMachinesParamsFree = 0
	GetMachinesParamsFreeN1 GetMachinesParamsFree = 1
)

// Defines values for GetMachinesParamsTodo.
const (
	GetMachinesParamsTodoN1 GetMachinesParamsTodo = 1
)

// Defines values for GetUserProfileContentParamsType.
const (
	GetUserProfileContentParamsTypeChallenge GetUserProfileContentParamsType = "challenge"
	GetUserProfileContentParamsTypeMachine   GetUserProfileContentParamsType = "machine"
	GetUserProfileContentParamsTypeSherlock  GetUserProfileContentParamsType = "sherlock"
)

// Connection defines model for Connection.
type Connection struct {
	union json.RawMessage
}

// ConnectionAssignedServer defines model for ConnectionAssignedServer.
type ConnectionAssignedServer struct {
	CurrentClients int    `json:"current_clients,omitempty"`
	FriendlyName   string `json:"friendly_name,omitempty"`
	Id             int    `json:"id,omitempty"`
	Location       string `json:"location,omitempty"`
}

// ConnectionBase defines model for ConnectionBase.
type ConnectionBase struct {
	AssignedServer       ConnectionAssignedServer `json:"assigned_server"`
	LocationTypeFriendly string                   `json:"location_type_friendly"`
	Type                 string                   `json:"type"`
}

// ConnectionCompetitiveEntry defines model for ConnectionCompetitiveEntry.
type ConnectionCompetitiveEntry struct {
	AssignedServer       ConnectionAssignedServer       `json:"assigned_server"`
	Available            bool                           `json:"available"`
	LocationTypeFriendly string                         `json:"location_type_friendly"`
	Machine              ConnectionMachine              `json:"machine,omitempty"`
	Type                 ConnectionCompetitiveEntryType `json:"type"`
}

// ConnectionCompetitiveEntryType defines model for ConnectionCompetitiveEntry.Type.
type ConnectionCompetitiveEntryType string

// ConnectionLabEntry defines model for ConnectionLabEntry.
type ConnectionLabEntry struct {
	AssignedServer       ConnectionAssignedServer `json:"assigned_server"`
	LocationTypeFriendly string                   `json:"location_type_friendly"`
	Type                 ConnectionLabEntryType   `json:"type"`
}

// ConnectionLabEntryType defines model for ConnectionLabEntry.Type.
type ConnectionLabEntryType string

// ConnectionMachine defines model for ConnectionMachine.
type ConnectionMachine struct {
	AvatarThumbUrl string `json:"avatar_thumb_url,omitempty"`
	Id             int    `json:"id,omitempty"`
	Name           string `json:"name,omitempty"`
}

// ConnectionProLabEntry defines model for ConnectionProLabEntry.
type ConnectionProLabEntry struct {
	AssignedServer       ConnectionAssignedServer  `json:"assigned_server"`
	LocationTypeFriendly string                    `json:"location_type_friendly"`
	ProLab               ConnectionProlab          `json:"pro_lab"`
	Type                 ConnectionProLabEntryType `json:"type"`
}

// ConnectionProLabEntryType defines model for ConnectionProLabEntry.Type.
type ConnectionProLabEntryType string

// ConnectionProlab defines model for ConnectionProlab.
type ConnectionProlab struct {
	Id         int    `json:"id,omitempty"`
	Identifier string `json:"identifier,omitempty"`
	Name       string `json:"name,omitempty"`
}

// ConnectionsData defines model for ConnectionsData.
type ConnectionsData = []Connection

// ConnectionsResponse Schema definition for Connections Response
type ConnectionsResponse struct {
	Data ConnectionsData `json:"data,omitempty"`
}

// FeedbackForChart defines model for FeedbackForChart.
type FeedbackForChart struct {
	CounterBitHard   int `json:"counterBitHard,omitempty"`
	CounterBrainFuck int `json:"counterBrainFuck,omitempty"`
	CounterCake      int `json:"counterCake,omitempty"`
	CounterEasy      int `json:"counterEasy,omitempty"`
	CounterExHard    int `json:"counterExHard,omitempty"`
	CounterHard      int `json:"counterHard,omitempty"`
	CounterMedium    int `json:"counterMedium,omitempty"`
	CounterTooEasy   int `json:"counterTooEasy,omitempty"`
	CounterTooHard   int `json:"counterTooHard,omitempty"`
	CounterVeryEasy  int `json:"counterVeryEasy,omitempty"`
}

// Generic400Response Schema definition for Generic Error Response
type Generic400Response struct {
	Message string `json:"message"`
	Status  int    `json:"status"`
}

// Links Schema definition for Links
type Links struct {
	First string `json:"first,omitempty"`
	Last  string `json:"last,omitempty"`
	Next  string `json:"next"`
	Prev  string `json:"prev"`
}

// MachineCreator defines model for MachineCreator.
type MachineCreator struct {
	Avatar      string `json:"avatar,omitempty"`
	Id          int    `json:"id,omitempty"`
	IsRespected bool   `json:"isRespected,omitempty"`
	Name        string `json:"name,omitempty"`
	ProfileUrl  string `json:"profile_url"`
}

// MachineLabel defines model for MachineLabel.
type MachineLabel struct {
	Color string `json:"color,omitempty"`
	Name  string `json:"name,omitempty"`
}

// MachineOwnErrorResponse Schema definition for Own Error Response
type MachineOwnErrorResponse struct {
	Message string `json:"message"`
	Status  int    `json:"status"`
}

// MachineOwnRequest Schema definition for Own Request
type MachineOwnRequest struct {
	Difficulty int `json:"difficulty,omitempty"`

	// Flag MD5 hash of the machine flag
	Flag string `json:"flag"`

	// Id The machine ID
	Id int `json:"id"`
}

// MachineOwnResponse Schema definition for Machine Own Response
type MachineOwnResponse struct {
	BloodPoints      int                       `json:"blood_points"`
	BloodTaken       int                       `json:"blood_taken"`
	Id               int                       `json:"id"`
	IsStartingPoint  bool                      `json:"is_starting_point"`
	LeagueRank       RankUpdate                `json:"league_rank,omitempty"`
	MachineCompleted bool                      `json:"machine_completed"`
	MachinePwned     bool                      `json:"machine_pwned"`
	MachineState     string                    `json:"machine_state"`
	Message          string                    `json:"message"`
	OwnType          MachineOwnResponseOwnType `json:"own_type"`
	Points           int                       `json:"points"`
	Status           int                       `json:"status"`
	Success          bool                      `json:"success"`
	UserRank         RankUpdate                `json:"user_rank,omitempty"`
}

// MachineOwnResponseOwnType defines model for MachineOwnResponse.OwnType.
type MachineOwnResponseOwnType string

// MachinePlayInfo defines model for MachinePlayInfo.
type MachinePlayInfo struct {
	ActivePlayerCount int       `json:"active_player_count"`
	ExpiresAt         time.Time `json:"expires_at"`
	IsActive          bool      `json:"isActive"`
	IsSpawned         bool      `json:"isSpawned"`
	IsSpawning        bool      `json:"isSpawning"`
}

// MachineRetiring defines model for MachineRetiring.
type MachineRetiring struct {
	Avatar         string `json:"avatar,omitempty"`
	DifficultyText string `json:"difficultyText,omitempty"`
	Id             int    `json:"id,omitempty"`
	Name           string `json:"name,omitempty"`
	Os             string `json:"os,omitempty"`
}

// MachinesData defines model for MachinesData.
type MachinesData = []MachinesItem

// MachinesItem Schema definition for a Machine card
type MachinesItem struct {
	Active                   bool             `json:"active"`
	AuthUserHasReviewed      bool             `json:"authUserHasReviewed"`
	AuthUserInRootOwns       bool             `json:"authUserInRootOwns"`
	AuthUserInUserOwns       bool             `json:"authUserInUserOwns"`
	Avatar                   string           `json:"avatar"`
	Cocreators               []MachineCreator `json:"cocreators"`
	Competitive              bool             `json:"competitive"`
	Difficulty               int              `json:"difficulty"`
	DifficultyText           string           `json:"difficultyText"`
	FeedbackForChart         FeedbackForChart `json:"feedbackForChart"`
	FirstCreator             MachineCreator   `json:"firstCreator"`
	Free                     bool             `json:"free"`
	Id                       int              `json:"id"`
	Ip                       string           `json:"ip"`
	IsSingleFlag             bool             `json:"isSingleFlag"`
	Labels                   []MachineLabel   `json:"labels"`
	Name                     string           `json:"name"`
	Os                       string           `json:"os"`
	PlayInfo                 MachinePlayInfo  `json:"playInfo"`
	Points                   int              `json:"points"`
	PriceTier                int              `json:"priceTier"`
	Rating                   float32          `json:"rating"`
	RatingCount              int              `json:"ratingCount"`
	Recommended              bool             `json:"recommended"`
	ReleaseDate              time.Time        `json:"releaseDate"`
	RequiredSubscription     string           `json:"requiredSubscription"`
	RetiredDate              time.Time        `json:"retiredDate"`
	Retiring                 MachineRetiring  `json:"retiring"`
	RootOwnsCount            int              `json:"rootOwnsCount"`
	SpFlag                   int              `json:"spFlag"`
	State                    string           `json:"state"`
	TaskCompletionPercentage string           `json:"taskCompletionPercentage"`
	Todo                     bool             `json:"todo"`
	UserOwnsCount            int              `json:"userOwnsCount"`
}

// MachinesResponse Schema definition for Machines list responses
type MachinesResponse struct {
	Data MachinesData `json:"data"`

	// Links Schema definition for Links
	Links Links `json:"links"`

	// Meta Schema definition for Meta
	Meta Meta `json:"meta"`
}

// Meta Schema definition for Meta
type Meta struct {
	CurrentPage int             `json:"current_page,omitempty"`
	From        int             `json:"from,omitempty"`
	LastPage    int             `json:"last_page,omitempty"`
	Links       PaginationLinks `json:"links,omitempty"`
	Path        string          `json:"path,omitempty"`
	PerPage     int             `json:"per_page,omitempty"`
	To          int             `json:"to,omitempty"`
	Total       int             `json:"total,omitempty"`
}

// MetaAlt defines model for MetaAlt.
type MetaAlt struct {
	LastPage   int `json:"lastPage"`
	Page       int `json:"page"`
	TotalItems int `json:"totalItems"`
}

// NewRank defines model for NewRank.
type NewRank struct {
	Id   int    `json:"id,omitempty"`
	Text string `json:"text"`
}

// PaginationLink Schema definition for Pagination Link
type PaginationLink struct {
	Active bool   `json:"active,omitempty"`
	Label  string `json:"label,omitempty"`
	Page   int    `json:"page"`
	Url    string `json:"url"`
}

// PaginationLinks defines model for PaginationLinks.
type PaginationLinks = []PaginationLink

// RankUpdate defines model for RankUpdate.
type RankUpdate struct {
	Changed bool    `json:"changed,omitempty"`
	NewRank NewRank `json:"newRank,omitempty"`
}

// UserDashboardChallenge Summary information for a challenge card surfaced on dashboard endpoints.
type UserDashboardChallenge struct {
	// Avatar Relative asset path for the challenge category icon.
	Avatar string `json:"avatar"`

	// AvatarUrl Absolute URL for the challenge avatar.
	AvatarUrl string `json:"avatarUrl"`

	// CategoryID Numerical identifier for the challenge category.
	CategoryID int `json:"categoryID"`

	// CategoryName Name of the challenge category.
	CategoryName string `json:"categoryName"`

	// Difficulty Challenge difficulty label.
	Difficulty string `json:"difficulty"`

	// Id Challenge identifier.
	Id int `json:"id"`

	// Name Challenge display name.
	Name string `json:"name"`

	// Points Points available for the challenge.
	Points int `json:"points"`

	// Progress Completion percentage for the challenge if applicable.
	Progress int `json:"progress"`

	// Rating Average user rating for the challenge.
	Rating float32 `json:"rating"`

	// RatingCount Number of rating submissions.
	RatingCount int `json:"ratingCount"`

	// Status Availability label such as vip.
	Status string `json:"status"`

	// Type Resource type label (e.g., Retired Challenge).
	Type string `json:"type"`

	// Url Relative link to the challenge page.
	Url string `json:"url"`

	// UrlName Challenge slug used in URLs.
	UrlName string `json:"urlName"`
}

// UserDashboardCollections Collections returned by dashboard endpoints such as favorites, in progress, and recommended.
type UserDashboardCollections struct {
	// Challenges Challenge cards curated for the user.
	Challenges []UserDashboardChallenge `json:"challenges"`

	// Fortresses Fortresses relevant to the dashboard view.
	Fortresses []UserDashboardFortress `json:"fortresses"`

	// Machines Machines relevant to the dashboard section.
	Machines []UserDashboardMachine `json:"machines"`

	// ProLabs Pro Lab recommendations or progress items.
	ProLabs []UserDashboardProlab `json:"proLabs"`

	// Sherlocks Sherlock investigations that match the dashboard filter.
	Sherlocks []UserDashboardSherlock `json:"sherlocks"`

	// StartingPoints Starting Point tiers associated with the user.
	StartingPoints []UserDashboardStartingPoint `json:"startingPoints"`

	// Tracks Tracks highlighted for the user.
	Tracks []UserDashboardTrack `json:"tracks"`
}

// UserDashboardFavoritesResponse Collections returned by dashboard endpoints such as favorites, in progress, and recommended.
type UserDashboardFavoritesResponse = UserDashboardCollections

// UserDashboardFortress Summary information for fortress cards surfaced on dashboard views.
type UserDashboardFortress struct {
	// AvatarUrl Absolute URL for the fortress avatar.
	AvatarUrl string `json:"avatarUrl"`

	// Id Fortress identifier.
	Id int `json:"id"`

	// Name Fortress display name.
	Name string `json:"name"`

	// Points Points available for the fortress.
	Points int `json:"points"`

	// Progress Completion percentage for the fortress.
	Progress int `json:"progress"`

	// SolvesCount Number of user solves recorded.
	SolvesCount int `json:"solvesCount"`

	// TasksCompleted Completed fortress tasks.
	TasksCompleted int `json:"tasksCompleted"`

	// TasksTotal Total fortress tasks.
	TasksTotal int `json:"tasksTotal"`

	// Type Resource type label (e.g., Fortress).
	Type string `json:"type"`
}

// UserDashboardInProgressResponse Collections returned by dashboard endpoints such as favorites, in progress, and recommended.
type UserDashboardInProgressResponse = UserDashboardCollections

// UserDashboardMachine Summary information for a machine card shown on dashboard endpoints.
type UserDashboardMachine struct {
	// Avatar Relative asset path for the machine avatar.
	Avatar string `json:"avatar"`

	// AvatarUrl Absolute URL for the machine avatar.
	AvatarUrl string `json:"avatarUrl"`

	// Difficulty Difficulty label as shown in the UI.
	Difficulty string `json:"difficulty"`

	// Guided Whether the machine is part of a guided experience.
	Guided bool `json:"guided"`

	// Id Internal machine identifier.
	Id int `json:"id"`

	// Name Machine display name.
	Name string `json:"name"`

	// Os Operating system of the machine.
	Os string `json:"os"`

	// Points Points awarded for the machine.
	Points int `json:"points"`

	// Progress Overall completion percentage.
	Progress int `json:"progress"`

	// Rating Average user rating.
	Rating float32 `json:"rating"`

	// RatingCount Number of ratings submitted.
	RatingCount int `json:"ratingCount"`

	// RootFlag Indicates whether the user captured the root flag.
	RootFlag bool `json:"root_flag"`

	// Status Subscription requirement or availability label.
	Status string `json:"status"`

	// TasksCompleted Tasks completed within the machine entry.
	TasksCompleted int `json:"tasksCompleted"`

	// TasksTotal Total tasks available for the machine entry.
	TasksTotal int `json:"tasksTotal"`

	// Type Machine status label (e.g., Active Machine).
	Type string `json:"type"`

	// Url Relative link to the machine detail page.
	Url string `json:"url"`

	// UserFlag Indicates whether the user captured the user flag.
	UserFlag bool `json:"user_flag"`
}

// UserDashboardProlab Summary information for Pro Lab entries shown on dashboard endpoints.
type UserDashboardProlab struct {
	// Avatar Relative asset path for the lab image.
	Avatar string `json:"avatar"`

	// AvatarUrl Absolute URL for the lab image.
	AvatarUrl string `json:"avatarUrl"`

	// CategoryName Track or certification name associated with the lab.
	CategoryName string `json:"categoryName"`

	// Difficulty Reported difficulty for the lab.
	Difficulty string `json:"difficulty"`

	// Id Pro Lab identifier.
	Id int `json:"id"`

	// Identifier Short identifier or slug.
	Identifier string `json:"identifier"`

	// Name Pro Lab display name.
	Name string `json:"name"`

	// Progress Completion percentage inside the lab.
	Progress int `json:"progress"`

	// Rating Average participant rating.
	Rating float32 `json:"rating"`

	// RatingCount Number of participant ratings.
	RatingCount int `json:"ratingCount"`

	// TasksCompleted Completed task count.
	TasksCompleted int `json:"tasksCompleted"`

	// TasksTotal Total task count.
	TasksTotal int `json:"tasksTotal"`

	// Type Resource type label (e.g., Pro Lab).
	Type string `json:"type"`

	// Url Relative link to the Pro Lab overview.
	Url string `json:"url"`
}

// UserDashboardRecommendedResponse Collections returned by dashboard endpoints such as favorites, in progress, and recommended.
type UserDashboardRecommendedResponse = UserDashboardCollections

// UserDashboardSherlock Summary information for Sherlock investigations displayed in dashboard feeds.
type UserDashboardSherlock struct {
	// Avatar Relative asset path for the Sherlock image.
	Avatar string `json:"avatar"`

	// AvatarUrl Absolute URL for the Sherlock image.
	AvatarUrl string `json:"avatarUrl"`

	// CategoryID Numerical identifier for the Sherlock category.
	CategoryID int `json:"categoryID"`

	// CategoryName Human readable category label.
	CategoryName string `json:"categoryName"`

	// Difficulty Difficulty rating for the Sherlock.
	Difficulty string `json:"difficulty"`

	// Id Sherlock identifier.
	Id int `json:"id"`

	// Name Sherlock display name.
	Name string `json:"name"`

	// Progress Completion percentage.
	Progress int `json:"progress"`

	// Rating Average user rating.
	Rating float32 `json:"rating"`

	// RatingCount Count of user ratings.
	RatingCount int `json:"ratingCount"`

	// Status Availability label.
	Status string `json:"status"`

	// TasksCompleted Number of Sherlock tasks completed.
	TasksCompleted int `json:"tasksCompleted"`

	// TasksTotal Total Sherlock tasks available.
	TasksTotal int `json:"tasksTotal"`

	// Type Resource type label (e.g., Retired Sherlock).
	Type string `json:"type"`

	// Url Relative link to the Sherlock page.
	Url string `json:"url"`

	// UrlName Sherlock slug used in URLs.
	UrlName string `json:"urlName"`
}

// UserDashboardStartingPoint Summary information for a Starting Point tier card.
type UserDashboardStartingPoint struct {
	// Avatar Relative asset path for the tier avatar.
	Avatar string `json:"avatar"`

	// AvatarUrl Absolute URL to the tier avatar.
	AvatarUrl string `json:"avatarUrl"`

	// CompletionPercentage Overall completion percentage for the tier.
	CompletionPercentage int `json:"completionPercentage"`

	// Description Short tier description shown in the dashboard.
	Description string `json:"description"`

	// FreeMachineCompletionPercentage Completion percentage for free machines within the tier.
	FreeMachineCompletionPercentage int `json:"freeMachineCompletionPercentage"`

	// Id Tier identifier.
	Id int `json:"id"`

	// Name Tier display name.
	Name string `json:"name"`

	// Progress Percentage progress toward finishing the tier.
	Progress int `json:"progress"`

	// TasksCompleted Number of tasks completed.
	TasksCompleted int `json:"tasksCompleted"`

	// TasksTotal Total number of tasks available.
	TasksTotal int `json:"tasksTotal"`

	// Type Resource type label (e.g., Starting Point).
	Type string `json:"type"`
}

// UserDashboardTrack Summary information for track cards surfaced on dashboard views.
type UserDashboardTrack struct {
	// Avatar Relative asset path for the track image.
	Avatar string `json:"avatar"`

	// AvatarUrl Absolute URL for the track image.
	AvatarUrl string `json:"avatarUrl"`

	// Difficulty Difficulty level assigned to the track.
	Difficulty string `json:"difficulty"`

	// Id Track identifier.
	Id int `json:"id"`

	// LikeCount Number of likes.
	LikeCount int `json:"likeCount"`

	// Name Track display name.
	Name string `json:"name"`

	// Progress Completion percentage inside the track.
	Progress int `json:"progress"`

	// TasksCompleted Number of completed tasks.
	TasksCompleted int `json:"tasksCompleted"`

	// TasksTotal Total number of tasks.
	TasksTotal int `json:"tasksTotal"`

	// Type Resource type label (e.g., Track).
	Type string `json:"type"`

	// Url Relative link to the track landing page.
	Url string `json:"url"`
}

// UserProfileActivityBase defines model for UserProfileActivityBase.
type UserProfileActivityBase struct {
	Avatar  string    `json:"avatar,omitempty"`
	Blood   bool      `json:"blood"`
	Id      int       `json:"id"`
	Name    string    `json:"name"`
	OwnDate time.Time `json:"ownDate"`
	Points  int       `json:"points"`
	Type    string    `json:"type"`
}

// UserProfileActivityChallenge defines model for UserProfileActivityChallenge.
type UserProfileActivityChallenge struct {
	Avatar       string                           `json:"avatar,omitempty"`
	Blood        bool                             `json:"blood"`
	CategoryName string                           `json:"categoryName"`
	Id           int                              `json:"id"`
	Name         string                           `json:"name"`
	OwnDate      time.Time                        `json:"ownDate"`
	Points       int                              `json:"points"`
	Type         UserProfileActivityChallengeType `json:"type"`
}

// UserProfileActivityChallengeType defines model for UserProfileActivityChallenge.Type.
type UserProfileActivityChallengeType string

// UserProfileActivityData defines model for UserProfileActivityData.
type UserProfileActivityData = []UserProfileActivityItem

// UserProfileActivityFortress defines model for UserProfileActivityFortress.
type UserProfileActivityFortress struct {
	Avatar       string                          `json:"avatar,omitempty"`
	Blood        bool                            `json:"blood"`
	FortressId   int                             `json:"fortressId"`
	FortressName string                          `json:"fortressName"`
	Id           int                             `json:"id"`
	Name         string                          `json:"name"`
	OwnDate      time.Time                       `json:"ownDate"`
	Points       int                             `json:"points"`
	Type         UserProfileActivityFortressType `json:"type"`
}

// UserProfileActivityFortressType defines model for UserProfileActivityFortress.Type.
type UserProfileActivityFortressType string

// UserProfileActivityItem defines model for UserProfileActivityItem.
type UserProfileActivityItem struct {
	union json.RawMessage
}

// UserProfileActivityMachineBase defines model for UserProfileActivityMachineBase.
type UserProfileActivityMachineBase struct {
	Avatar  string    `json:"avatar,omitempty"`
	Blood   bool      `json:"blood"`
	Id      int       `json:"id"`
	Name    string    `json:"name"`
	OwnDate time.Time `json:"ownDate"`
	Points  int       `json:"points"`
	Type    string    `json:"type"`
}

// UserProfileActivityMachineOwn defines model for UserProfileActivityMachineOwn.
type UserProfileActivityMachineOwn struct {
	Avatar  string                            `json:"avatar,omitempty"`
	Blood   bool                              `json:"blood"`
	Id      int                               `json:"id"`
	Name    string                            `json:"name"`
	OwnDate time.Time                         `json:"ownDate"`
	Points  int                               `json:"points"`
	Type    UserProfileActivityMachineOwnType `json:"type"`
}

// UserProfileActivityMachineOwnType defines model for UserProfileActivityMachineOwn.Type.
type UserProfileActivityMachineOwnType string

// UserProfileActivityProlab defines model for UserProfileActivityProlab.
type UserProfileActivityProlab struct {
	Avatar           string                        `json:"avatar,omitempty"`
	Blood            bool                          `json:"blood"`
	Id               int                           `json:"id"`
	Name             string                        `json:"name"`
	OwnDate          time.Time                     `json:"ownDate"`
	Points           int                           `json:"points"`
	ProlabId         int                           `json:"prolabId"`
	ProlabIdentifier string                        `json:"prolabIdentifier"`
	ProlabName       string                        `json:"prolabName"`
	Type             UserProfileActivityProlabType `json:"type"`
}

// UserProfileActivityProlabType defines model for UserProfileActivityProlab.Type.
type UserProfileActivityProlabType string

// UserProfileActivityResponse Schema definition for User profile activity responses
type UserProfileActivityResponse struct {
	Data UserProfileActivityData `json:"data"`
	Meta MetaAlt                 `json:"meta"`
}

// UserProfileActivitySherlock defines model for UserProfileActivitySherlock.
type UserProfileActivitySherlock struct {
	Avatar  string                          `json:"avatar,omitempty"`
	Blood   bool                            `json:"blood"`
	Id      int                             `json:"id"`
	Name    string                          `json:"name"`
	OwnDate time.Time                       `json:"ownDate"`
	Points  int                             `json:"points"`
	Type    UserProfileActivitySherlockType `json:"type"`
}

// UserProfileActivitySherlockType defines model for UserProfileActivitySherlock.Type.
type UserProfileActivitySherlockType string

// UserProfileContentData Collection of user profile content entries.
type UserProfileContentData = []UserProfileContentItem

// UserProfileContentItem One of the possible content entries returned for a user profile.
type UserProfileContentItem struct {
	union json.RawMessage
}

// UserProfileContentItemChallenge Challenge entry returned by the user profile content feed.
type UserProfileContentItemChallenge struct {
	// CategoryName Challenge category name.
	CategoryName string `json:"categoryName"`

	// Difficulty Challenge difficulty label.
	Difficulty string `json:"difficulty"`

	// Id Challenge identifier.
	Id int `json:"id"`

	// Name Challenge display name.
	Name string `json:"name"`

	// OwnCount User completion count.
	OwnCount int `json:"ownCount"`

	// RatingCount Number of ratings recorded for the challenge.
	RatingCount int `json:"ratingCount"`

	// ReleaseDate Challenge release timestamp.
	ReleaseDate time.Time `json:"releaseDate"`

	// StarRating Average star rating.
	StarRating float32 `json:"starRating"`
}

// UserProfileContentItemMachine Machine entry returned by the user profile content feed.
type UserProfileContentItemMachine struct {
	// Difficulty Machine difficulty label.
	Difficulty string `json:"difficulty"`

	// Id Machine identifier.
	Id int `json:"id"`

	// MachineAvatar Absolute URL to the machine avatar.
	MachineAvatar string `json:"machineAvatar"`

	// Name Machine display name.
	Name string `json:"name"`

	// Os Operating system of the machine.
	Os string `json:"os"`

	// RatingCount Number of ratings submitted for the machine.
	RatingCount int `json:"ratingCount"`

	// ReleaseDate Machine release timestamp.
	ReleaseDate time.Time `json:"releaseDate"`

	// RootOwnCount Number of root owns for the profile owner.
	RootOwnCount int `json:"rootOwnCount"`

	// StarRating Average star rating.
	StarRating float32 `json:"starRating"`

	// UserOwnCount Number of user owns for the profile owner.
	UserOwnCount int `json:"userOwnCount"`
}

// UserProfileContentItemSherlock Sherlock investigation entry returned by the user profile content feed.
type UserProfileContentItemSherlock struct {
	// Avatar Absolute URL to the Sherlock avatar.
	Avatar string `json:"avatar"`

	// CategoryName Category the Sherlock belongs to.
	CategoryName string `json:"categoryName"`

	// Difficulty Sherlock difficulty label.
	Difficulty string `json:"difficulty"`

	// Id Sherlock identifier.
	Id int `json:"id"`

	// Name Sherlock display name.
	Name string `json:"name"`

	// OwnCount User completion count.
	OwnCount int `json:"ownCount"`

	// RatingCount Total user ratings recorded.
	RatingCount int `json:"ratingCount"`

	// ReleaseDate Sherlock release timestamp.
	ReleaseDate time.Time `json:"releaseDate"`

	// StarRating Average star rating.
	StarRating float32 `json:"starRating"`
}

// UserProfileContentResponse Schema definition for User profile content responses.
type UserProfileContentResponse struct {
	// Data Collection of user profile content entries.
	Data UserProfileContentData `json:"data"`
	Meta MetaAlt                `json:"meta"`
}

// Free defines model for Free.
type Free int

// Keyword defines model for Keyword.
type Keyword = string

// MachineDifficulty defines model for MachineDifficulty.
type MachineDifficulty = []string

// Os defines model for Os.
type Os = []string

// Page defines model for Page.
type Page = int

// PerPage defines model for PerPage.
type PerPage = int

// ShowCompleted defines model for ShowCompleted.
type ShowCompleted string

// SortBy defines model for SortBy.
type SortBy string

// SortType defines model for SortType.
type SortType string

// State defines model for State.
type State = []string

// Todo defines model for Todo.
type Todo int

// UserId defines model for UserId.
type UserId = int

// UserProfileContentType defines model for UserProfileContentType.
type UserProfileContentType string

// MachineOwn400Response Schema definition for Own Error Response
type MachineOwn400Response = MachineOwnErrorResponse

// GetMachinesParams defines parameters for GetMachines.
type GetMachinesParams struct {
	// PerPage Limit results per page
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Page Page number
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// State Filter by state. You can provide multiple values. For example, state=active&state=retired.
	State *State `form:"state,omitempty" json:"state,omitempty"`

	// Keyword Search String
	Keyword *Keyword `form:"keyword,omitempty" json:"keyword,omitempty"`

	// Difficulty Filter by difficulty level
	Difficulty *MachineDifficulty `form:"difficulty[],omitempty" json:"difficulty[],omitempty"`

	// Os Filter by os
	Os *Os `form:"os[],omitempty" json:"os[],omitempty"`

	// ShowCompleted Omit for both
	ShowCompleted *GetMachinesParamsShowCompleted `form:"show_completed,omitempty" json:"show_completed,omitempty"`

	// SortBy Field to sort by
	SortBy *GetMachinesParamsSortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// SortType Sort type (asc or desc)
	SortType *GetMachinesParamsSortType `form:"sort_type,omitempty" json:"sort_type,omitempty"`

	// Free limits retired results to free machines, values must either be 1 for true or 0 for false or omit the parameter for no filter
	Free *GetMachinesParamsFree `form:"free,omitempty" json:"free,omitempty"`

	// Todo Filter ToDo
	Todo GetMachinesParamsTodo `form:"todo,omitempty" json:"todo,omitempty"`
}

// GetMachinesParamsState defines parameters for GetMachines.
type GetMachinesParamsState string

// GetMachinesParamsDifficulty defines parameters for GetMachines.
type GetMachinesParamsDifficulty string

// GetMachinesParamsOs defines parameters for GetMachines.
type GetMachinesParamsOs string

// GetMachinesParamsShowCompleted defines parameters for GetMachines.
type GetMachinesParamsShowCompleted string

// GetMachinesParamsSortBy defines parameters for GetMachines.
type GetMachinesParamsSortBy string

// GetMachinesParamsSortType defines parameters for GetMachines.
type GetMachinesParamsSortType string

// GetMachinesParamsFree defines parameters for GetMachines.
type GetMachinesParamsFree int

// GetMachinesParamsTodo defines parameters for GetMachines.
type GetMachinesParamsTodo int

// GetUserProfileActivityParams defines parameters for GetUserProfileActivity.
type GetUserProfileActivityParams struct {
	// PerPage Limit results per page
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Page Page number
	Page *Page `form:"page,omitempty" json:"page,omitempty"`
}

// GetUserProfileContentParams defines parameters for GetUserProfileContent.
type GetUserProfileContentParams struct {
	// Type Product type to filter by
	Type GetUserProfileContentParamsType `form:"type" json:"type"`

	// PerPage Limit results per page
	PerPage *PerPage `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Page Page number
	Page *Page `form:"page,omitempty" json:"page,omitempty"`
}

// GetUserProfileContentParamsType defines parameters for GetUserProfileContent.
type GetUserProfileContentParamsType string

// PostMachineOwnJSONRequestBody defines body for PostMachineOwn for application/json ContentType.
type PostMachineOwnJSONRequestBody = MachineOwnRequest

// PostMachineOwnFormdataRequestBody defines body for PostMachineOwn for application/x-www-form-urlencoded ContentType.
type PostMachineOwnFormdataRequestBody = MachineOwnRequest

// AsConnectionLabEntry returns the union data inside the Connection as a ConnectionLabEntry
func (t Connection) AsConnectionLabEntry() (ConnectionLabEntry, error) {
	var body ConnectionLabEntry
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConnectionLabEntry overwrites any union data inside the Connection as the provided ConnectionLabEntry
func (t *Connection) FromConnectionLabEntry(v ConnectionLabEntry) error {
	v.Type = "starting_point"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConnectionLabEntry performs a merge with any union data inside the Connection, using the provided ConnectionLabEntry
func (t *Connection) MergeConnectionLabEntry(v ConnectionLabEntry) error {
	v.Type = "starting_point"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsConnectionProLabEntry returns the union data inside the Connection as a ConnectionProLabEntry
func (t Connection) AsConnectionProLabEntry() (ConnectionProLabEntry, error) {
	var body ConnectionProLabEntry
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConnectionProLabEntry overwrites any union data inside the Connection as the provided ConnectionProLabEntry
func (t *Connection) FromConnectionProLabEntry(v ConnectionProLabEntry) error {
	v.Type = "prolab"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConnectionProLabEntry performs a merge with any union data inside the Connection, using the provided ConnectionProLabEntry
func (t *Connection) MergeConnectionProLabEntry(v ConnectionProLabEntry) error {
	v.Type = "prolab"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsConnectionCompetitiveEntry returns the union data inside the Connection as a ConnectionCompetitiveEntry
func (t Connection) AsConnectionCompetitiveEntry() (ConnectionCompetitiveEntry, error) {
	var body ConnectionCompetitiveEntry
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConnectionCompetitiveEntry overwrites any union data inside the Connection as the provided ConnectionCompetitiveEntry
func (t *Connection) FromConnectionCompetitiveEntry(v ConnectionCompetitiveEntry) error {
	v.Type = "competitive"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConnectionCompetitiveEntry performs a merge with any union data inside the Connection, using the provided ConnectionCompetitiveEntry
func (t *Connection) MergeConnectionCompetitiveEntry(v ConnectionCompetitiveEntry) error {
	v.Type = "competitive"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Connection) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t Connection) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "competitive":
		return t.AsConnectionCompetitiveEntry()
	case "prolab":
		return t.AsConnectionProLabEntry()
	case "starting_point":
		return t.AsConnectionLabEntry()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t Connection) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Connection) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsUserProfileActivityFortress returns the union data inside the UserProfileActivityItem as a UserProfileActivityFortress
func (t UserProfileActivityItem) AsUserProfileActivityFortress() (UserProfileActivityFortress, error) {
	var body UserProfileActivityFortress
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUserProfileActivityFortress overwrites any union data inside the UserProfileActivityItem as the provided UserProfileActivityFortress
func (t *UserProfileActivityItem) FromUserProfileActivityFortress(v UserProfileActivityFortress) error {
	v.Type = "fortress"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUserProfileActivityFortress performs a merge with any union data inside the UserProfileActivityItem, using the provided UserProfileActivityFortress
func (t *UserProfileActivityItem) MergeUserProfileActivityFortress(v UserProfileActivityFortress) error {
	v.Type = "fortress"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUserProfileActivityMachineOwn returns the union data inside the UserProfileActivityItem as a UserProfileActivityMachineOwn
func (t UserProfileActivityItem) AsUserProfileActivityMachineOwn() (UserProfileActivityMachineOwn, error) {
	var body UserProfileActivityMachineOwn
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUserProfileActivityMachineOwn overwrites any union data inside the UserProfileActivityItem as the provided UserProfileActivityMachineOwn
func (t *UserProfileActivityItem) FromUserProfileActivityMachineOwn(v UserProfileActivityMachineOwn) error {
	v.Type = "root"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUserProfileActivityMachineOwn performs a merge with any union data inside the UserProfileActivityItem, using the provided UserProfileActivityMachineOwn
func (t *UserProfileActivityItem) MergeUserProfileActivityMachineOwn(v UserProfileActivityMachineOwn) error {
	v.Type = "root"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUserProfileActivityChallenge returns the union data inside the UserProfileActivityItem as a UserProfileActivityChallenge
func (t UserProfileActivityItem) AsUserProfileActivityChallenge() (UserProfileActivityChallenge, error) {
	var body UserProfileActivityChallenge
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUserProfileActivityChallenge overwrites any union data inside the UserProfileActivityItem as the provided UserProfileActivityChallenge
func (t *UserProfileActivityItem) FromUserProfileActivityChallenge(v UserProfileActivityChallenge) error {
	v.Type = "challenge"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUserProfileActivityChallenge performs a merge with any union data inside the UserProfileActivityItem, using the provided UserProfileActivityChallenge
func (t *UserProfileActivityItem) MergeUserProfileActivityChallenge(v UserProfileActivityChallenge) error {
	v.Type = "challenge"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUserProfileActivitySherlock returns the union data inside the UserProfileActivityItem as a UserProfileActivitySherlock
func (t UserProfileActivityItem) AsUserProfileActivitySherlock() (UserProfileActivitySherlock, error) {
	var body UserProfileActivitySherlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUserProfileActivitySherlock overwrites any union data inside the UserProfileActivityItem as the provided UserProfileActivitySherlock
func (t *UserProfileActivityItem) FromUserProfileActivitySherlock(v UserProfileActivitySherlock) error {
	v.Type = "sherlock"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUserProfileActivitySherlock performs a merge with any union data inside the UserProfileActivityItem, using the provided UserProfileActivitySherlock
func (t *UserProfileActivityItem) MergeUserProfileActivitySherlock(v UserProfileActivitySherlock) error {
	v.Type = "sherlock"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUserProfileActivityProlab returns the union data inside the UserProfileActivityItem as a UserProfileActivityProlab
func (t UserProfileActivityItem) AsUserProfileActivityProlab() (UserProfileActivityProlab, error) {
	var body UserProfileActivityProlab
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUserProfileActivityProlab overwrites any union data inside the UserProfileActivityItem as the provided UserProfileActivityProlab
func (t *UserProfileActivityItem) FromUserProfileActivityProlab(v UserProfileActivityProlab) error {
	v.Type = "prolab"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUserProfileActivityProlab performs a merge with any union data inside the UserProfileActivityItem, using the provided UserProfileActivityProlab
func (t *UserProfileActivityItem) MergeUserProfileActivityProlab(v UserProfileActivityProlab) error {
	v.Type = "prolab"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t UserProfileActivityItem) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t UserProfileActivityItem) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "challenge":
		return t.AsUserProfileActivityChallenge()
	case "fortress":
		return t.AsUserProfileActivityFortress()
	case "prolab":
		return t.AsUserProfileActivityProlab()
	case "root":
		return t.AsUserProfileActivityMachineOwn()
	case "sherlock":
		return t.AsUserProfileActivitySherlock()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t UserProfileActivityItem) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UserProfileActivityItem) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsUserProfileContentItemMachine returns the union data inside the UserProfileContentItem as a UserProfileContentItemMachine
func (t UserProfileContentItem) AsUserProfileContentItemMachine() (UserProfileContentItemMachine, error) {
	var body UserProfileContentItemMachine
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUserProfileContentItemMachine overwrites any union data inside the UserProfileContentItem as the provided UserProfileContentItemMachine
func (t *UserProfileContentItem) FromUserProfileContentItemMachine(v UserProfileContentItemMachine) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUserProfileContentItemMachine performs a merge with any union data inside the UserProfileContentItem, using the provided UserProfileContentItemMachine
func (t *UserProfileContentItem) MergeUserProfileContentItemMachine(v UserProfileContentItemMachine) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUserProfileContentItemChallenge returns the union data inside the UserProfileContentItem as a UserProfileContentItemChallenge
func (t UserProfileContentItem) AsUserProfileContentItemChallenge() (UserProfileContentItemChallenge, error) {
	var body UserProfileContentItemChallenge
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUserProfileContentItemChallenge overwrites any union data inside the UserProfileContentItem as the provided UserProfileContentItemChallenge
func (t *UserProfileContentItem) FromUserProfileContentItemChallenge(v UserProfileContentItemChallenge) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUserProfileContentItemChallenge performs a merge with any union data inside the UserProfileContentItem, using the provided UserProfileContentItemChallenge
func (t *UserProfileContentItem) MergeUserProfileContentItemChallenge(v UserProfileContentItemChallenge) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUserProfileContentItemSherlock returns the union data inside the UserProfileContentItem as a UserProfileContentItemSherlock
func (t UserProfileContentItem) AsUserProfileContentItemSherlock() (UserProfileContentItemSherlock, error) {
	var body UserProfileContentItemSherlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUserProfileContentItemSherlock overwrites any union data inside the UserProfileContentItem as the provided UserProfileContentItemSherlock
func (t *UserProfileContentItem) FromUserProfileContentItemSherlock(v UserProfileContentItemSherlock) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUserProfileContentItemSherlock performs a merge with any union data inside the UserProfileContentItem, using the provided UserProfileContentItemSherlock
func (t *UserProfileContentItem) MergeUserProfileContentItemSherlock(v UserProfileContentItemSherlock) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t UserProfileContentItem) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UserProfileContentItem) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetConnections request
	GetConnections(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostMachineOwnWithBody request with any body
	PostMachineOwnWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostMachineOwn(ctx context.Context, body PostMachineOwnJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostMachineOwnWithFormdataBody(ctx context.Context, body PostMachineOwnFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMachines request
	GetMachines(ctx context.Context, params *GetMachinesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserProfileActivity request
	GetUserProfileActivity(ctx context.Context, userId UserId, params *GetUserProfileActivityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserProfileContent request
	GetUserProfileContent(ctx context.Context, userId UserId, params *GetUserProfileContentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserDashboardFavorites request
	GetUserDashboardFavorites(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserDashboardInProgress request
	GetUserDashboardInProgress(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserDashboardRecommended request
	GetUserDashboardRecommended(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetConnections(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConnectionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostMachineOwnWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostMachineOwnRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostMachineOwn(ctx context.Context, body PostMachineOwnJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostMachineOwnRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostMachineOwnWithFormdataBody(ctx context.Context, body PostMachineOwnFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostMachineOwnRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMachines(ctx context.Context, params *GetMachinesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMachinesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserProfileActivity(ctx context.Context, userId UserId, params *GetUserProfileActivityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserProfileActivityRequest(c.Server, userId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserProfileContent(ctx context.Context, userId UserId, params *GetUserProfileContentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserProfileContentRequest(c.Server, userId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserDashboardFavorites(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserDashboardFavoritesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserDashboardInProgress(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserDashboardInProgressRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserDashboardRecommended(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserDashboardRecommendedRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetConnectionsRequest generates requests for GetConnections
func NewGetConnectionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/connections")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostMachineOwnRequest calls the generic PostMachineOwn builder with application/json body
func NewPostMachineOwnRequest(server string, body PostMachineOwnJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostMachineOwnRequestWithBody(server, "application/json", bodyReader)
}

// NewPostMachineOwnRequestWithFormdataBody calls the generic PostMachineOwn builder with application/x-www-form-urlencoded body
func NewPostMachineOwnRequestWithFormdataBody(server string, body PostMachineOwnFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewPostMachineOwnRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewPostMachineOwnRequestWithBody generates requests for PostMachineOwn with any type of body
func NewPostMachineOwnRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/machine/own")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetMachinesRequest generates requests for GetMachines
func NewGetMachinesRequest(server string, params *GetMachinesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/machines")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.State != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, *params.State); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Keyword != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "keyword", runtime.ParamLocationQuery, *params.Keyword); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Difficulty != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "difficulty[]", runtime.ParamLocationQuery, *params.Difficulty); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Os != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "os[]", runtime.ParamLocationQuery, *params.Os); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ShowCompleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "show_completed", runtime.ParamLocationQuery, *params.ShowCompleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_type", runtime.ParamLocationQuery, *params.SortType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Free != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "free", runtime.ParamLocationQuery, *params.Free); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "todo", runtime.ParamLocationQuery, params.Todo); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserProfileActivityRequest generates requests for GetUserProfileActivity
func NewGetUserProfileActivityRequest(server string, userId UserId, params *GetUserProfileActivityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/profile/activity/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserProfileContentRequest generates requests for GetUserProfileContent
func NewGetUserProfileContentRequest(server string, userId UserId, params *GetUserProfileContentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/profile/content/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, params.Type); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserDashboardFavoritesRequest generates requests for GetUserDashboardFavorites
func NewGetUserDashboardFavoritesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/profile/dashboard/favorites")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserDashboardInProgressRequest generates requests for GetUserDashboardInProgress
func NewGetUserDashboardInProgressRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/profile/dashboard/inprogress")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserDashboardRecommendedRequest generates requests for GetUserDashboardRecommended
func NewGetUserDashboardRecommendedRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/profile/dashboard/recommended")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetConnectionsWithResponse request
	GetConnectionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetConnectionsResponse, error)

	// PostMachineOwnWithBodyWithResponse request with any body
	PostMachineOwnWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostMachineOwnResponse, error)

	PostMachineOwnWithResponse(ctx context.Context, body PostMachineOwnJSONRequestBody, reqEditors ...RequestEditorFn) (*PostMachineOwnResponse, error)

	PostMachineOwnWithFormdataBodyWithResponse(ctx context.Context, body PostMachineOwnFormdataRequestBody, reqEditors ...RequestEditorFn) (*PostMachineOwnResponse, error)

	// GetMachinesWithResponse request
	GetMachinesWithResponse(ctx context.Context, params *GetMachinesParams, reqEditors ...RequestEditorFn) (*GetMachinesResponse, error)

	// GetUserProfileActivityWithResponse request
	GetUserProfileActivityWithResponse(ctx context.Context, userId UserId, params *GetUserProfileActivityParams, reqEditors ...RequestEditorFn) (*GetUserProfileActivityResponse, error)

	// GetUserProfileContentWithResponse request
	GetUserProfileContentWithResponse(ctx context.Context, userId UserId, params *GetUserProfileContentParams, reqEditors ...RequestEditorFn) (*GetUserProfileContentResponse, error)

	// GetUserDashboardFavoritesWithResponse request
	GetUserDashboardFavoritesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUserDashboardFavoritesResponse, error)

	// GetUserDashboardInProgressWithResponse request
	GetUserDashboardInProgressWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUserDashboardInProgressResponse, error)

	// GetUserDashboardRecommendedWithResponse request
	GetUserDashboardRecommendedWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUserDashboardRecommendedResponse, error)
}

type GetConnectionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConnectionsResponse
	JSON400      *Generic400Response
}

// Status returns HTTPResponse.Status
func (r GetConnectionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConnectionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostMachineOwnResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MachineOwnResponse
	JSON400      *MachineOwn400Response
}

// Status returns HTTPResponse.Status
func (r PostMachineOwnResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostMachineOwnResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMachinesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MachinesResponse
	JSON400      *Generic400Response
}

// Status returns HTTPResponse.Status
func (r GetMachinesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMachinesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserProfileActivityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserProfileActivityResponse
	JSON400      *Generic400Response
}

// Status returns HTTPResponse.Status
func (r GetUserProfileActivityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserProfileActivityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserProfileContentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserProfileContentResponse
	JSON400      *Generic400Response
}

// Status returns HTTPResponse.Status
func (r GetUserProfileContentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserProfileContentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserDashboardFavoritesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserDashboardFavoritesResponse
	JSON400      *Generic400Response
}

// Status returns HTTPResponse.Status
func (r GetUserDashboardFavoritesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserDashboardFavoritesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserDashboardInProgressResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserDashboardInProgressResponse
	JSON400      *Generic400Response
}

// Status returns HTTPResponse.Status
func (r GetUserDashboardInProgressResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserDashboardInProgressResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserDashboardRecommendedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserDashboardRecommendedResponse
	JSON400      *Generic400Response
}

// Status returns HTTPResponse.Status
func (r GetUserDashboardRecommendedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserDashboardRecommendedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetConnectionsWithResponse request returning *GetConnectionsResponse
func (c *ClientWithResponses) GetConnectionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetConnectionsResponse, error) {
	rsp, err := c.GetConnections(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConnectionsResponse(rsp)
}

// PostMachineOwnWithBodyWithResponse request with arbitrary body returning *PostMachineOwnResponse
func (c *ClientWithResponses) PostMachineOwnWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostMachineOwnResponse, error) {
	rsp, err := c.PostMachineOwnWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostMachineOwnResponse(rsp)
}

func (c *ClientWithResponses) PostMachineOwnWithResponse(ctx context.Context, body PostMachineOwnJSONRequestBody, reqEditors ...RequestEditorFn) (*PostMachineOwnResponse, error) {
	rsp, err := c.PostMachineOwn(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostMachineOwnResponse(rsp)
}

func (c *ClientWithResponses) PostMachineOwnWithFormdataBodyWithResponse(ctx context.Context, body PostMachineOwnFormdataRequestBody, reqEditors ...RequestEditorFn) (*PostMachineOwnResponse, error) {
	rsp, err := c.PostMachineOwnWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostMachineOwnResponse(rsp)
}

// GetMachinesWithResponse request returning *GetMachinesResponse
func (c *ClientWithResponses) GetMachinesWithResponse(ctx context.Context, params *GetMachinesParams, reqEditors ...RequestEditorFn) (*GetMachinesResponse, error) {
	rsp, err := c.GetMachines(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMachinesResponse(rsp)
}

// GetUserProfileActivityWithResponse request returning *GetUserProfileActivityResponse
func (c *ClientWithResponses) GetUserProfileActivityWithResponse(ctx context.Context, userId UserId, params *GetUserProfileActivityParams, reqEditors ...RequestEditorFn) (*GetUserProfileActivityResponse, error) {
	rsp, err := c.GetUserProfileActivity(ctx, userId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserProfileActivityResponse(rsp)
}

// GetUserProfileContentWithResponse request returning *GetUserProfileContentResponse
func (c *ClientWithResponses) GetUserProfileContentWithResponse(ctx context.Context, userId UserId, params *GetUserProfileContentParams, reqEditors ...RequestEditorFn) (*GetUserProfileContentResponse, error) {
	rsp, err := c.GetUserProfileContent(ctx, userId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserProfileContentResponse(rsp)
}

// GetUserDashboardFavoritesWithResponse request returning *GetUserDashboardFavoritesResponse
func (c *ClientWithResponses) GetUserDashboardFavoritesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUserDashboardFavoritesResponse, error) {
	rsp, err := c.GetUserDashboardFavorites(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserDashboardFavoritesResponse(rsp)
}

// GetUserDashboardInProgressWithResponse request returning *GetUserDashboardInProgressResponse
func (c *ClientWithResponses) GetUserDashboardInProgressWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUserDashboardInProgressResponse, error) {
	rsp, err := c.GetUserDashboardInProgress(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserDashboardInProgressResponse(rsp)
}

// GetUserDashboardRecommendedWithResponse request returning *GetUserDashboardRecommendedResponse
func (c *ClientWithResponses) GetUserDashboardRecommendedWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUserDashboardRecommendedResponse, error) {
	rsp, err := c.GetUserDashboardRecommended(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserDashboardRecommendedResponse(rsp)
}

// ParseGetConnectionsResponse parses an HTTP response from a GetConnectionsWithResponse call
func ParseGetConnectionsResponse(rsp *http.Response) (*GetConnectionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConnectionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConnectionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Generic400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostMachineOwnResponse parses an HTTP response from a PostMachineOwnWithResponse call
func ParsePostMachineOwnResponse(rsp *http.Response) (*PostMachineOwnResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostMachineOwnResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MachineOwnResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest MachineOwn400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetMachinesResponse parses an HTTP response from a GetMachinesWithResponse call
func ParseGetMachinesResponse(rsp *http.Response) (*GetMachinesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMachinesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MachinesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Generic400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetUserProfileActivityResponse parses an HTTP response from a GetUserProfileActivityWithResponse call
func ParseGetUserProfileActivityResponse(rsp *http.Response) (*GetUserProfileActivityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserProfileActivityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserProfileActivityResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Generic400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetUserProfileContentResponse parses an HTTP response from a GetUserProfileContentWithResponse call
func ParseGetUserProfileContentResponse(rsp *http.Response) (*GetUserProfileContentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserProfileContentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserProfileContentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Generic400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetUserDashboardFavoritesResponse parses an HTTP response from a GetUserDashboardFavoritesWithResponse call
func ParseGetUserDashboardFavoritesResponse(rsp *http.Response) (*GetUserDashboardFavoritesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserDashboardFavoritesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserDashboardFavoritesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Generic400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetUserDashboardInProgressResponse parses an HTTP response from a GetUserDashboardInProgressWithResponse call
func ParseGetUserDashboardInProgressResponse(rsp *http.Response) (*GetUserDashboardInProgressResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserDashboardInProgressResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserDashboardInProgressResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Generic400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetUserDashboardRecommendedResponse parses an HTTP response from a GetUserDashboardRecommendedWithResponse call
func ParseGetUserDashboardRecommendedResponse(rsp *http.Response) (*GetUserDashboardRecommendedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserDashboardRecommendedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserDashboardRecommendedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Generic400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}
